---
layout: post
title: "HITB - Impossible Password Writeup"
categories: Reverse Engineering
---

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

# Tools used to solve this challenge

|VirtualBox (Ubuntu 19.10 (Eoan Ermine) Virtual Machine)|sufficiently secure environment for Reverse Engineering challenges|
|---|---|
|*tmux*|For partitioning terminal windows|
|*Ghidra*|Disassembler|
|---|---|
|*strings*|Data gathering from binary file's mapped to memory|
|---|---|
|*file* command|Provides us with potentially useful information about the type of binary file.|
|---|---|

# Challenge Message

*Are you able to cheat me and get the flag?*

---

# Walk-Through

The first thing to do is download the zip archive for this challenge and verify the authenticity
of the downloaded file by its SHA256 checksum.

The extracted file is a binary file. My first move is to run the binary file against the <a href="https://man7.org/linux/man-pages/man1/file.1.html" target="_blank">file command</a>, to determine the kind of we are dealing with. The binary file is an <a href="https://upload.wikimedia.org/wikipedia/commons/e/e4/ELF_Executable_and_Linkable_Format_diagram_by_Ange_Albertini.png" target="_blank">executable ELF file</a>

{:refdef style="text-align: center;"}
![file-command](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/HITB-password-file.png){:height="100%" width="100%"}
{:refdef}

Notice that the file has been stripped. This is most likely to make debugging it the binary more of a challenge.

{:refdef style="text-align: center;"}
![strings-command](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/HITB-password-strings.png){:height="75%" width="75%"}
{:refdef}

*strings* shows us the standard header information and strings stored in the binary executable file. A few strings
stand out here.

- **<span style="color:red">SuperSeKretKey</span>:** This hints at a key that might be used when the program is run.
- **<span style="color:green">%20s</span>:** This looks like some formatting based upon the <span style="color:green">%</span> symbol and the same with <span style="color:green">[%s]</span>.
- **<a href="https://www.redhat.com/en/technologies/linux-platforms/enterprise-linux" target="_blank">Red Hat</a> with <span style="color:blue">GCC</span>:** an executable compiled from C code. Also the presence of <a href="https://refspecs.linuxbase.org/LSB_3.1.0/LSB-generic/LSB-generic/baselib---libc-start-main-.html" target="_blank">__libc_start_main</a> in the strings output indicates that a main() function is present in this C program.

There is also malloc for memory allocation and strcmp to compare strings which could be used for password verification, if for example
this executable recieves user input.

## Static Analysis

Now, we have some tangible information about the type of binary file we are working with and some useful strings that we can use a signposts, we can now dig deeper into the behaviour of our binary. For this, I will use Ghidra.

{:refdef style="text-align: center;"}
![Ghidra](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/Ghidra.png){:height="40%" width="40%"}
{:refdef}

Since the binary file has been stripped, the main function was not interpreted directly by Ghidra, so working through the disassembly I deduced which function was *main()*. I then read through the disassembly for each function called in *main()* and renamed them based upon what I think they are doing and converted the local variables to characters for ease of readability. This is the result.

<pre>
<code class="c">
void main(void) {
       int iVar1;
       char *stage2_str;
       byte local_48;
       undefined local_47;
       undefined local_46;
       undefined local_45;
       undefined local_44;
       undefined local_43;
       undefined local_42;
       undefined local_41;
       undefined local_40;
       undefined local_3f;
       undefined local_3e;
       undefined local_3d;
       undefined local_3c;
       undefined local_3b;
       undefined local_3a;
       undefined local_39;
       undefined local_38;
       undefined local_37;
       undefined local_36;
       undefined local_35;
       char user_input [20];
       int local_14;
       char *stage1_str;

       stage1_str = "SuperSeKretKey";
       local_48 = 'A';
       local_47 = ']';
       local_46 = 'K';
       local_45 = 'r';
       local_44 = '=';
       local_43 = '9';
       local_42 = 'k';
       local_41 = '0';
       local_40 = '=';
       local_3f = '0';
       local_3e = 'o';
       local_3d = '0';
       local_3c = ';';
       local_3b = 'k';
       local_3a = '1';
       local_39 = '?';
       local_38 = 'k';
       local_37 = '8';
       local_36 = '1';
       local_35 = 't';

       printf("* ");

       __isoc99_scanf(&format,user_input);

       printf("[%s]\n",user_input);

       local_14 = strcmp(user_input,stage1_str);
       if (local_14 != 0) {
       	  	  exit(1);
       }
       printf("** ");

       __isoc99_scanf(&format,user_input);
       stage2_str = (char *)generate_second_key(0x14);
       iVar1 = strcmp(user_input,stage2_str);

	if (iVar1 == 0) {
	   	print_decrypted_flag(&local_48);
	}
	return;
}
</code>
</pre>

*printf()*, *scanf()* and *strcmp()* were all determined by Ghidra. *generate_second_key()* is interesting. It uses C's rand() in-built
function and conducts some kind of re-ordering or data. However, as you will see in the Dynamic Analysis below, I bypassed this function
to retrieve the HITB flag.

## Dynamic Analysis

Above, we discovered that the binary file has been <a href="https://medium.com/@tr0id/working-with-stripped-binaries-in-gdb-cacacd7d5a33" target="_blank">stripped</a>. This means a flag was set during compilation that directs the compiler to discard
debugging symbols. Therefore, we are required to manually determine the entrypoint to the program.

For Dynamic Analysis, I am using <a href="https://www.gnu.org/software/gdb/" target="_blank">GDB</a>.

We can do this with either the ```info file``` or the ```info target``` command.

{:refdef style="text-align: center;"}
![info-file](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/HITB-password-gdb-info-file.png){:height="75%" width="75%"}
{:refdef}

So our entrypoint to the program is at the address ```0x4006a0``` in hex. In other words, the program data starts at this
location in memory. Our objective is to arrive at the main() function, which we need to find.

{:refdef style="text-align: center;"}
![break-at-entrypoint](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/break-at-entrypoint.png){:height="30%" width="30%"}
{:refdef}

Setting a breakpoint at ```0x4006a0``` and typing and returning ```r``` (short for run), the program is run up to this memory location.

{:refdef style="text-align: center;"}
![20instructions](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/20instructions.png){:height="60%" width="60%"}
{:refdef}

{:refdef style="text-align: center;"}
![ghidra-entrypoint](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/ghidra-entrypoint.png){:height="75%" width="75%"}
{:refdef}

In Ghidra, I identified that the main function is not called directly. Instead, ```main()``` is passed into the RDI register
before ```__libc_start_main``` is called. This is probably a form of obfuscation on the ```main()``` function. Cross-referencing
the dis-assembly in Ghidra with GDB, the main function must reside at the location ```0x40085d``` in memory.

{:refdef style="text-align: center;"}
![gdb-to-main](http://127.0.0.1:4000/personal-website/assets/HITB-writeups/Impossible-Password/gdb-to-main.png){:height="40%" width="40%"}
{:refdef}

Setting a breakpoint at ```main()``` and continuing there with the command ```c``` (short for continue).